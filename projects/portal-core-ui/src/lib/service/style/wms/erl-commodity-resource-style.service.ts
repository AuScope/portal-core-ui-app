import { Injectable } from '@angular/core';
import { serialize } from '@thi.ng/hiccup';

interface ErlCommodityStyleParams {
  optionalFilters?: OptionalFilter[];
  color?: string;
  gsmlNamespace: string;
  gmlNamespace: string;
  erlNamespace: string;
}

interface OptionalFilter {
  value: string;
  label: string;
  xpath: string;
  predicate: string;
  type: string;
  added: boolean;
}

@Injectable()
export class ErlCommodityStyleService {

  public static getSld(layerName: string, styleName: string, params: ErlCommodityStyleParams): string {
    const ns = {
      sld: 'http://www.opengis.net/sld',
      ogc: 'http://www.opengis.net/ogc',
      gml: 'urn:cgi:xmlns:CGI:GeoSciML:2.0',
      gsml: 'http://www.opengis.net/gml',
      erl: 'http://xmlns.earthresourceml.org/EarthResource/2.0',
      xlink: 'http://www.w3.org/1999/xlink',
      xsi: 'http://www.w3.org/2001/XMLSchema-instance'
    };

    const baseFilter = this.createBaseFilter(params.optionalFilters || []);
    const color = params.color || '#940ea3';

    return serialize(
      ['sld:StyledLayerDescriptor', { 
        version: '1.0.0',
        'xmlns:sld': ns.sld,
        'xmlns:ogc': ns.ogc,
        'xmlns:gml': ns.gml,
        'xmlns:gsml': ns.gsml,
        'xmlns:erl': ns.erl,
        'xmlns:xlink': ns.xlink,
        'xmlns:xsi': ns.xsi,
        'xsi:schemaLocation': [
          `${ns.sld} StyledLayerDescriptor.xsd`,
          `${ns.gml} http://schemas.opengis.net/gml/3.1.1/base/gml.xsd`,
          `${ns.gsml} http://schemas.geosciml.org/geosciml/2.0/geosciml.xsd`
        ].join(' ')
      },
        ['sld:NamedLayer', {},
          ['sld:Name', {}, layerName],
          ['sld:UserStyle', {},
            ['sld:Name', {}, styleName],
            ['sld:Title', {}, styleName],
            ['sld:Abstract', {}, 'Commodity Resource style generated by AuScope Portal'],
            this.createFeatureTypeStyle(baseFilter, color, ns)
          ]
        ]
      ]
    );
  }

  private static createFeatureTypeStyle(filter: string, color: string, ns: any): any[] {
    return [
      'sld:FeatureTypeStyle', {},
      ['sld:Rule', {},
        filter.includes('<ogc:Filter>') ? filter : ['ogc:Filter', {}, filter],
        this.createSymbolizer(color, ns)
      ]
    ];
  }

  private static createSymbolizer(color: string, ns: any): any[] {
    return [
      'sld:PointSymbolizer', {},
      ['sld:Graphic', {},
        ['sld:Mark', {},
          ['sld:WellKnownName', {}, 'circle'],
          ['sld:Fill', {},
            ['sld:CssParameter', { name: 'fill' }, color],
            ['sld:CssParameter', { name: 'fill-opacity' }, '0.4']
          ],
          ['sld:Stroke', {},
            ['sld:CssParameter', { name: 'stroke' }, color],
            ['sld:CssParameter', { name: 'stroke-width' }, '1']
          ]
        ],
        ['sld:Size', {}, '8']
      ]
    ];
  }

  private static createBaseFilter(filters: OptionalFilter[]): string {
    const filterParts: string[] = [];
    
    filters.forEach(filter => {
      switch(filter.type) {
        case 'OPTIONAL.POLYGONBBOX':
          filterParts.push(this.createPolygonFilter(filter));
          break;
        case 'OPTIONAL.DATE':
          filterParts.push(this.createDateFilter(filter));
          break;
        case 'OPTIONAL.TEXT':
          filterParts.push(this.createTextFilter(filter));
          break;
        case 'OPTIONAL.DROPDOWNREMOTE':
          filterParts.push(this.createDropdownFilter(filter));
          break;
      }
    });

    return filterParts.length > 0
      ? `<ogc:Filter><ogc:And>${filterParts.join('')}</ogc:And></ogc:Filter>`
      : '<ogc:Filter/>';
  }

  private static createPolygonFilter(filter: OptionalFilter): string {
    return `<ogc:Intersects>
      <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
      ${filter.value}
    </ogc:Intersects>`;
  }

  private static createDateFilter(filter: OptionalFilter): string {
    const operator = filter.predicate === 'BIGGER_THAN' 
      ? 'PropertyIsGreaterThan' 
      : 'PropertyIsLessThan';
      
    return `<ogc:${operator}>
      <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
      <ogc:Literal>${filter.value}</ogc:Literal>
    </ogc:${operator}>`;
  }

  private static createTextFilter(filter: OptionalFilter): string {
    if (filter.predicate === 'ISLIKE') {
        return `<ogc:PropertyIsLike wildCard="*" singleChar="#" escapeChar="!">
            <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
            <ogc:Literal>*${filter.value}*</ogc:Literal>
        </ogc:PropertyIsLike>`;
    }
    return `<ogc:PropertyIsEqualTo>
        <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
        <ogc:Literal>${filter.value}</ogc:Literal>
    </ogc:PropertyIsEqualTo>`;
  }

  private static createDropdownFilter(filter: OptionalFilter): string {
    return `<ogc:PropertyIsEqualTo>
        <ogc:PropertyName>${filter.xpath}</ogc:PropertyName>
        <ogc:Literal>${filter.value}</ogc:Literal>
    </ogc:PropertyIsEqualTo>`;
  }
} 